---
description: Основная архитектура проекта Zatochka - гексагональная архитектура, паттерны и принципы
globs:
alwaysApply: true
---

# Основная архитектура проекта Zatochka

## Технологический стек

### Backend (PHP)

-   **Laravel 12.0** - основной фреймворк
-   **PHP 8.2+** - минимальная версия
-   **Filament 3.3** - админ-панель
-   **Laravel Fortify** - аутентификация
-   **Laravel Sanctum** - API токены
-   **Laravel Horizon** - управление очередями
-   **Laravel Telescope** - отладка и мониторинг

### Пакеты Spatie

-   **laravel-permission** - роли и права доступа
-   **laravel-activitylog** - логирование действий
-   **laravel-event-sourcing** - Event Sourcing
-   **laravel-data** - Data Transfer Objects
-   **laravel-query-builder** - построение запросов
-   **laravel-medialibrary** - работа с медиафайлами

### Frontend

-   **Vue 3.2** - реактивный фреймворк
-   **Tailwind CSS 4.1** - CSS фреймворк
-   **Bootstrap 5.2** - UI компоненты
-   **GSAP 3.13** - анимации
-   **Maska 3.2** - маски ввода
-   **Vite 7.0** - сборщик

### Инструменты разработки

-   **PHPStan** - статический анализ
-   **Psalm** - анализ типов
-   **PHP CS Fixer** - форматирование кода
-   **PHPUnit** - тестирование
-   **Laravel Debugbar** - отладка

## Архитектурные принципы

### 1. Гексагональная архитектура (Hexagonal Architecture)

Проект использует гексагональную архитектуру с разделением на слои:

-   **Domain** - бизнес-логика и правила (ядро приложения)
-   **Application** - Use Cases и сервисы приложения
-   **Infrastructure** - внешние зависимости (БД, API, файлы)
-   **Presentation** - UI слой (Filament, Controllers)

### 2. Use Cases Pattern

-   **Application/UseCases** - бизнес-сценарии приложения
-   Каждый Use Case решает одну задачу
-   Инкапсулирует бизнес-логику
-   Независимы от UI и инфраструктуры
-   Базовые классы для каждого домена:
    -   `BaseOrderUseCase` для заказов
    -   `BaseClientUseCase` для клиентов
    -   `BaseBonusUseCase` для бонусной системы
-   Интерфейсы для каждого домена:
    -   `UseCaseInterface` для заказов
    -   `ClientUseCaseInterface` для клиентов
    -   `BonusUseCaseInterface` для бонусной системы

### 3. Event Sourcing

-   **Spatie Event Sourcing** - полная реализация Event Sourcing
-   Доменные события для всех основных сущностей
-   Aggregate Roots для инкапсуляции бизнес-логики
-   Projectors для построения read-моделей
-   Reactors для обработки side-effects
-   Автоматическое восстановление состояния из событий
-   Аудит и трассировка всех изменений

### 4. Repository Pattern

-   Интерфейсы в Domain слое
-   Реализации в Infrastructure слое
-   Абстракция доступа к данным
-   Методы для проверки существования записей (existsByNumber)

### 5. Mapper Pattern

-   Интерфейсы мапперов в Domain слое
-   Реализации в Infrastructure слое
-   Преобразование между Domain Entity и Eloquent Model
-   Двунаправленное маппирование (toDomain, toEloquent, fromArray)

## Структура приложения

### Гексагональная архитектура

**Domain (app/Domain/)**

-   Бизнес-логика и правила
-   Сущности и Value Objects (Order Entity, Client Entity, Bonus Entity)
-   **Aggregate Roots** для Event Sourcing:
    -   OrderAggregateRoot для заказов
    -   ClientAggregateRoot для клиентов
    -   BonusAccountAggregateRoot для бонусов
-   **Доменные события**:
    -   Order: OrderCreated, OrderStatusChanged
    -   Client: ClientCreated, ClientUpdated
    -   Bonus: BonusAccountCreated, BonusTransactionCreated
-   Интерфейсы репозиториев:
    -   OrderRepository для заказов
    -   ClientRepository для клиентов
    -   BonusAccountRepository, BonusTransactionRepository для бонусов
-   Интерфейсы мапперов (OrderMapper, ClientMapper, BonusMapper)
-   Доменные сервисы (OrderNumberGeneratorService, OrderStatusGroupingService)
-   Доменные исключения (OrderNumberAlreadyExistsException, OrderException)
-   DTO для передачи данных:
    -   Order: CreateOrderDTO, UpdateOrderDTO, GetOrderDTO
    -   Client: CreateClientDTO, UpdateClientDTO, GetClientDTO
    -   Bonus: CreateBonusAccountDTO, CreateBonusTransactionDTO
-   Enums для типизации (OrderStatus, OrderType, OrderUrgency, ClientStatus, ClientType)
-   Factory для создания объектов (OrderFactory, ClientFactory, BonusFactory)
-   FieldLabels для лейблов полей (Order/FieldLabels)
-   FieldValueFormatterService для форматирования значений

**Application (app/Application/)**

-   Use Cases - бизнес-сценарии:
    -   Order: CreateOrderUseCase, UpdateOrderUseCase, DeleteOrderUseCase, GetOrderUseCase
    -   Client: CreateClientUseCase, UpdateClientUseCase, DeleteClientUseCase, GetClientUseCase
    -   Bonus: CreateBonusAccountUseCase, CreateBonusTransactionUseCase, GetBonusAccountUseCase
-   Базовые классы для Use Cases:
    -   BaseOrderUseCase для заказов
    -   BaseClientUseCase для клиентов
    -   BaseBonusUseCase для бонусной системы
-   Интерфейсы Use Cases:
    -   UseCaseInterface для заказов
    -   ClientUseCaseInterface для клиентов
    -   BonusUseCaseInterface для бонусной системы
-   Сервисы приложения
-   DTO и команды
-   Интерфейсы сервисов

**Infrastructure (app/Infrastructure/)**

-   Реализации репозиториев:
    -   OrderRepositoryImpl для заказов
    -   ClientRepositoryImpl для клиентов
    -   BonusAccountRepositoryImpl, BonusTransactionRepositoryImpl для бонусов
-   Реализации мапперов:
    -   OrderMapperImpl для заказов
    -   ClientMapperImpl для клиентов
    -   BonusMapperImpl для бонусов
-   **Event Sourcing инфраструктура**:
    -   Таблицы stored_events и snapshots
    -   Конфигурация Spatie Event Sourcing
    -   Сериализация и нормализация событий
-   Внешние API клиенты
-   Файловые системы
-   Конфигурации
-   Методы для проверки существования записей (existsByNumber)

**Event Sourcing (app/Projectors/, app/Reactors/)**

-   **Projectors** для построения read-моделей:
    -   OrderProjector - проекция заказов
    -   ClientProjector - проекция клиентов
    -   BonusProjector - проекция бонусов
-   **Reactors** для обработки side-effects:
    -   OrderReactor - уведомления, интеграции
    -   ClientReactor - создание бонусных счетов
    -   BonusReactor - обновление балансов

## Паттерны проектирования

### 1. Use Cases Pattern

-   Бизнес-сценарии в `app/Application/UseCases/`
-   Каждый Use Case решает одну задачу
-   Независимы от UI и инфраструктуры
-   Легко тестируются

### 2. Repository Pattern

-   Интерфейсы в Domain слое
-   Реализации в Infrastructure слое
-   Абстракция доступа к данным
-   Методы для проверки существования записей (existsByNumber)

### 3. Service Layer

-   Бизнес-логика в сервисах (`app/Services/`)
-   Тонкие контроллеры
-   Переиспользуемые сервисы

### 3.1. Domain Services

-   Доменные сервисы в `app/Domain/Service/`
-   Инкапсулируют сложную бизнес-логику
-   Независимы от инфраструктуры
-   Легко тестируются и мокаются

### 4. Factory Pattern

-   Создание сложных объектов
-   Eloquent фабрики для тестов

### 5. Observer Pattern

-   События модели
-   Автоматические действия при изменениях

### 6. Strategy Pattern

-   Различные алгоритмы расчета
-   Плагинная архитектура

### 7. Active Record

-   Прямая работа с Eloquent моделями
-   Бизнес-логика в моделях
-   Scope методы для запросов

### 8. DTO Pattern

-   Data Transfer Objects для передачи данных между слоями
-   Валидация данных в DTO
-   Immutable объекты с readonly свойствами
-   Методы fromArray() и toArray() для сериализации

### 9. Factory Pattern (Domain)

-   Доменные фабрики для создания сложных объектов
-   Статические методы create() в Entity
-   Отдельные Factory классы для сложной логики создания

### 10. Enum Pattern

-   Типизированные перечисления для статусов и типов
-   Методы для получения меток и описаний
-   Бизнес-логика в enum методах (isFinal, isManagerStatus, etc.)

### 11. State Machine Pattern

-   Управление переходами между статусами заказов
-   Сервис OrderStatusGroupingService для логики переходов
-   Валидация допустимых переходов между статусами

### 12. Event Sourcing Pattern

-   **Aggregate Roots** - инкапсуляция бизнес-логики и событий
-   **Domain Events** - доменные события для всех изменений
-   **Projectors** - построение read-моделей из событий
-   **Reactors** - обработка side-effects при событиях
-   **Event Store** - хранение всех событий в таблице stored_events
-   **Snapshots** - снимки состояния для оптимизации
-   **Event Replay** - восстановление состояния из событий

## Новые архитектурные решения

### 1. Domain Entity Pattern

-   Полноценные доменные сущности вместо простых моделей
-   Инкапсуляция бизнес-логики в Entity
-   Immutable объекты с контролируемыми изменениями
-   Бизнес-методы для проверки состояний

### 2. Enum-based Status Management

-   Типизированные статусы через PHP 8.1+ Enums
-   Бизнес-логика в enum методах
-   Автоматическая валидация переходов между статусами
-   Группировка статусов по ролям (менеджер/мастер)

### 3. Use Case Architecture

-   Базовый класс для стандартизации Use Cases
-   Интерфейс для типизации Use Cases
-   Разделение валидации и выполнения
-   Интеграция с DTO для передачи данных

### 4. Mapper Layer

-   Отдельный слой для преобразования данных
-   Двунаправленное маппирование между слоями
-   Типизированные интерфейсы мапперов
-   Изоляция Domain от Infrastructure

### 5. State Machine для заказов

-   Централизованное управление переходами статусов
-   Валидация допустимых переходов
-   Группировка статусов по ролям пользователей
-   Автоматическое определение доступных действий

### 6. Бонусная система

-   Полноценная система начисления и трат бонусов
-   Настройки через Filament ресурс
-   Автоматическое логирование транзакций
-   Срок действия бонусов
-   Интеграция с заказами
-   **Event Sourcing интеграция** - создание бонусных аккаунтов через события
-   **Автоматическое создание** бонусного аккаунта при создании клиента
-   **ClientReactor** - обработка события ClientCreated для создания бонусного аккаунта
-   Use Cases: BaseBonusUseCase, BonusUseCaseInterface, CreateBonusAccountUseCase
-   Репозитории: BonusAccountRepository, BonusTransactionRepository
-   **Domain Entity**: BonusAccount с бизнес-логикой
-   **DTO**: CreateBonusAccountDTO для передачи данных
-   **Aggregate Root**: BonusAccountAggregateRoot для Event Sourcing
-   **События**: BonusAccountCreated для создания аккаунта

### 7. Клиентская система

-   Управление клиентами с полной доменной структурой
-   Валидация телефонов и уникальность
-   Управление статусами клиентов
-   Интеграция с бонусной системой
-   Связи с заказами, отзывами, уведомлениями
-   Use Cases: BaseClientUseCase, ClientUseCaseInterface
-   Репозиторий: ClientRepository
-   **Event Sourcing**: ClientAggregateRoot с методами createClient() и updateClient()
-   **Доменные события**: ClientCreated, ClientUpdated
-   **Автоматические side-effects**: создание бонусного аккаунта через ClientReactor

### 8. Event Sourcing архитектура

-   **Полная реализация Event Sourcing** через Spatie
-   **Aggregate Roots** для всех основных сущностей (Order, Client, BonusAccount)
-   **Доменные события** для всех изменений состояния:
    -   Order: OrderCreated, OrderStatusChanged
    -   Client: ClientCreated, ClientUpdated
    -   Bonus: BonusAccountCreated, BonusTransactionCreated
-   **Projectors** для построения read-моделей
-   **Reactors** для обработки side-effects (ClientReactor для создания бонусных аккаунтов)
-   **Event Store** с таблицами stored_events и snapshots
-   **Автоматическое восстановление** состояния из событий
-   **Аудит и трассировка** всех изменений в системе
-   **Простая реализация** без UUID - используется `new AggregateRoot()` и `retrieve()`
-   **Интеграция с Use Cases** - все изменения через агрегатные корни
-   **Автоматические side-effects** - создание связанных сущностей через Reactors

### 9. Структура бонусной системы с Event Sourcing

-   **Domain Layer**:
    -   `BonusAccount` Entity - доменная сущность с бизнес-логикой
    -   `CreateBonusAccountDTO` - DTO для передачи данных
    -   `BonusAccountAggregateRoot` - агрегатный корень для Event Sourcing
    -   `BonusAccountCreated` - событие создания бонусного аккаунта
    -   `BonusAccountRepository` - интерфейс репозитория
-   **Application Layer**:
    -   `CreateBonusAccountUseCase` - Use Case для создания бонусного аккаунта
    -   `BaseBonusUseCase` - базовый класс для бонусных Use Cases
    -   `BonusUseCaseInterface` - интерфейс для бонусных Use Cases
-   **Infrastructure Layer**:
    -   `BonusAccountRepositoryImpl` - реализация репозитория через Eloquent
    -   `BonusAccount` Eloquent модель - для работы с БД
-   **Event Sourcing**:
    -   `ClientReactor` - обработка события ClientCreated
    -   Автоматическое создание бонусного аккаунта при создании клиента
    -   Простая реализация без UUID - `new BonusAccountAggregateRoot()`

### 10. Filament интеграция с доменной архитектурой

-   **Use Cases в Filament** - все CRUD операции через доменные Use Cases
-   **Совместимость типов** - Filament ожидает Eloquent модели, Use Cases возвращают Domain Entity
-   **Правильные методы** - использование `mutateFormDataBeforeSave()`, `handleRecordCreation()`, `mount()`
-   **Обработка ошибок** - уведомления через `Notification::make()` при ошибках Use Cases
-   **Маппинг данных** - приведение типов в мапперах (bool, null, etc.)
-   **Валидация** - доменная валидация через Use Cases, UI валидация через Filament
-   **Отображение связанных данных** - eager loading для избежания N+1 проблем
-   **Бонусная система в UI** - отображение баланса бонусов в таблицах и формах просмотра

## Filament UI компоненты

### ClientResource

-   **Таблица клиентов**:
    -   Колонка "Бонусы" с форматированием (например: "0 бон.", "1,250 бон.")
    -   Цветные бейджи (зеленый для бонусов > 0, серый для 0)
    -   Сортировка по количеству бонусов
    -   Возможность скрыть/показать колонку
-   **Форма просмотра клиента**:
    -   Секция "Бонусная система"
    -   Текущий баланс бонусов
    -   Дата создания бонусного аккаунта
-   **Оптимизация**:
    -   Eager loading бонусных аккаунтов через `->with('bonusAccount')`
    -   Правильное форматирование чисел через `number_format()`

### Принципы отображения бонусов

-   **Форматирование**: `number_format($balance) . ' бон.'`
-   **Цвета бейджей**: `success` для бонусов > 0, `gray` для 0
-   **Обработка null**: показ "0 бон." если бонусный аккаунт не создан
-   **Eager loading**: всегда загружать связанные бонусные аккаунты
